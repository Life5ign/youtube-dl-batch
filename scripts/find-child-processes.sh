#!/bin/bash

# list processes that have a process group leader with the pid located in a
# file in the tmp directory, which is generated by the main srcipt and
# contains its pid

# source variables and functions using git rev-parse
source "$(git rev-parse --show-toplevel)/vars.sh"
source "$(git rev-parse --show-toplevel)/functions.sh"

# generate logs for this session
main_logger
path_logger

# usage
usage () {
	echo "$(basename $0): usage: $(basename $0) [--kill] [--pid <pid> |
        --file <file>]"
	return
}

# process positional parameters using while, case, and shift
kill_ps=
pid_file=
pid_number=

while [[ -n $1 ]]; do
    case $1 in
        -p | --pid)     shift
                        pid_number=$1
                        ;;
        -f | --file)    shift
                        pid_file=$1
                        ;;
        -k | --kill)    kill_ps=1
                        ;;
        *)              usage >&2
                        exit 1
                        ;;
    esac
    shift
done

# define files to store ps info and pids
CHILD_PROCESS_INFO_FILE="$(mktemp "${TMP_DIR}/${BASENAME_S}.$$.XXXXXXXXXX")"
CHILD_PROCESS_FILE="$(mktemp "${TMP_DIR}/${BASENAME_S}.$$.XXXXXXXXXX")"

# define a function to handle processes
evaluate_processes () {
    # print info about running processes with a group leading process specied
    # in the main script, killing them if specified in the main script.
    # Evaluate the group leading pid as the first positional parameter passed
    # to this function, and the kill option as the appropriate global variable

    local group_leader_pid=$1

    # print and write info about child processes with the specified group
    # leader
    if [[ $group_leader_pid -gt 0 ]]; then
    	ps -cxf -o pid,gid,pgid,rgid,tpgid -g $group_leader_pid \
            | tee $CHILD_PROCESS_INFO_FILE
        # echo -e "Wrote info about these processes to ${CHILD_PROCESS_INFO_FILE}...\n"
    
        # get the pids for these processes and write them to a file, one pid per
        # line
        # echo -e "Writing process ids to ${CHILD_PROCESS_FILE}\n" >&2
        # use sed to remove the header line from ps output and grab the pids in the
        # first column for all the remaining lines
    	CHILD_PIDS="$(ps -x -o pid -g "$group_leader_pid" \
            | sed -En -e '1! s/(^ *)([0-9]+)(.*)/\2/g p')"
    	echo -e "$CHILD_PIDS" > $CHILD_PROCESS_FILE

    else
        echo -e "PID $group_leader_pid is not a valid PID"
        exit 1
    fi
	
    # if specied in the main script, kill child processes
    if [[ -n "$kill_ps" ]]; then

        # the $(< ... ) form of command substituion in an alternative for cat
        # command substitution and is faster
        kill $(< "${CHILD_PROCESS_FILE}")
        KILLSTATUS="$?"

        if [[ "$KILLSTATUS" ]]; then
        	echo "Successfully killed processes in ${CHILD_PROCESS_FILE}"
        else
        	echo -e "kill exited unsuccessfully with status ${KILLSTATUS}"
        fi
    fi    

    return
}

# process global variables from input to script

if [[ -n "$pid_number" ]]; then
    evaluate_processes "$pid_number"
fi

if [[ -n "$pid_file" ]]; then
    if [[ -r $pid_file ]]; then

# echo -e "Found group leading pid file ${pid_file}\n" >&2
	group_leader_pid=$(cat $pid_file | sed 's/ //g')
# echo -e "Got pid $group_leader_pid from ${pid_file}\n" 
    evaluate_processes "$group_leader_pid"

    else
        echo -e "Cannot read file $pid_file" >&2
        exit 1
    fi
fi
